# Physical Modeling

물리적 모델링은 실제로 만들 데이터베이스에 가장 가깝게 데이터 모델을 만드는 과정이다.

각 요소들의 이름을 어떻게 지을지, 컬럼들의 데이터 타입은 어떻게 정할지, 어떤 DBMS를 사용할 것인지, 보안은 어떻게 해결할 것인지, 마스터 권한은 누구에게 있는지, DB를 몇개로 나눠서 사용할 것인지, 캐시(cache)는 어떻게 사용할 것인지 등등

<br/>

## Naming(이름 짓기)

- 단수/복수 정하기
  - user / users
- 대문자/띄어쓰기 정하기
  - product_id / ProductId
- 줄임말 정하기
  - social_security_number / ssn

<br/>

## Data Type

### 데이터 타입을 잘 정해야하는 이유

- 데이터 정확성을 지키기 위해서
  - age 컬럼의 데이터 타입을 INT로 지정했을 경우 다른 데이터 타입의 값이 저장되는 것을 막을 수 있다.

- 데이터베이스 연산/함수들을 제대로 활용하기 위해서
  - 알맞은 데이터 타입(날짜)를 지정한다.

- 데이터베이스 용량을 최적화하기 위해서

  - 데이터베이스의 용량이 커질수록 느려진다. 

  - 똑같은 데이터를 저장하되, 용량은 가장 작게 사용하는 것이 좋다.

  - age컬럼의 데이터 타입을 INT로 지정했을 경우, INT는 모든 정수가 아닌 -2,147,483,648 ~ 2,147,483,648의 정수를 저장할 수 있다.

  - **INT 형식에서는 모든 숫자를 동일하게 4 Byte 용량으로 저장한다.** 
    (0을 저장하는 용량 = 2,147,483,648을 저장하는 용량)

  - **데이터 타입마다 사용하는 저장용량이 다르다.** 
    TINYINT(1 BYTE), SMALLINT(2 BYTE), BIGINT(8 BYTE)

  - 때문에 age 컬럼을 TINYINT로 지정했을 경우 INT를 썼을 때 보다 1/4 만큼만 저장용량을 사용할 수 있다.

<br/>

## Index

특정 조건의 데이터를 찾는 조회를 굉장히 빠르게 할 수 있다.

그렇다고 해서 모든 컬럼과 모든 컬럼의 조합에 인덱스를 추가하지는 않는다.

**인덱스는 조회는 빠르게 할 수 있지만, 삽입/업데이트/삭제는 오히려 더 느리게 만든다.**
(인덱스를 추가하려는 테이블의 컬럼들이 얼마나 자주 삽입, 업데이트, 삭제되는지 파악)

인덱스 추가 기본 원칙

- 모든 Primary Key에 대해서 인덱스를 만들어 준다.
- 모든 Foreign Key에 대해서 인덱스를 만들어 준다.
- 특정 조회 쿼리가 너무 느려지거나, 느려질게 확실한 경우 조회에 사용되는 컬럼들에 대해서 인덱스를 만들어 준다.

| 선형 탐색(Linear Search)                                     | 이진 탐색(Binary Search)                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 아무 규칙없이 저장되어있는 데이터의 경우 선형 탐색이 가장 빠르다. | 데이터가 이미 정렬되어 있다면 이진 탐색이 빠르다.            |
| **시간복잡도 O(n)**<br />1024개의 숫자가 정렬되어 있을 때: 최대 1024번 만에 원하는 데이터를 찾을 수 있다. | **시간 복잡도 O(log(n))**<br />최대 11번 만에 원하는 데이터를 찾을 수 있다. |

<br/>

### Clustered Index

**테이블 자체를 특정 순서(email 컬럼)로 저장하는 인덱스**

- 조회 속도가 굉장히 빠르다.
- 인덱스를 하나밖에 못 만든다.
  - 영어 사전은 알파벳 순으로만 정렬되어있음

### Non-Clustered Index

**테이블 자체는 그대로 놔두고 다른 곳에 순서를 저장하는 인덱스**

- 인덱스를 모든 컬럼에 대해서 만들 수 있다.
- 실제 테이블과 다른 테이블에 저장되어있기 때문에 Clustered Index 보다는 조금 느리다.
- 단점
  - 인덱스 추가로 인한 **용량 문제**
  - 하나의 row값을 바꾸면, 해당 컬럼이 포함된 모든 인덱스를 수정해야하는 **업데이트 문제**
- 일반 책의 맨 뒷페이지 색인 또는 인덱스와 비슷한 개념

| 인덱스에 중복이 없는 경우                                    | 인덱스에 중복이 있는 경우                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <img src="https://user-images.githubusercontent.com/64063767/116777817-6378fb00-aaa9-11eb-9cc9-a9b243668fe2.png" alt="image" style="zoom:50%;" /> | <img src="https://user-images.githubusercontent.com/64063767/116777937-1e08fd80-aaaa-11eb-8339-4216effe7f5d.png" alt="image" style="zoom:50%;" /> |

### Composite Index

2개 또는 더 많은 여러 개의 조건을 사용해서 조회를 많이 할 때는 컬럼 하나가 아니라 여러 개에 대해서 인덱스를 만들 수 도 있다. (선형탐색 추가 없이 이진탐색만으로도 조회 가능)

브랜드와 색깔을 조건으로 조회할 때는, 중간에 종류 인덱스를 건너뛰기 때문에 인덱스를 사용할 수 없다.

그렇기 때문에 여러 컬럼에 대한 인덱스를 사용할 때는 항상 가장 왼쪽에 조건으로 가장 많이 사용하는 컬럼을 사용하고, 오른쪽으로 갈수록 조건으르 절 사용하는 컬럼을 사용해야 한다. 이렇게 하면 인덱스를 여러 개 저장하지 않아도, 조회를 빨리할 수 있는 효과를 만들 수 있다.

<img src="https://user-images.githubusercontent.com/64063767/116778021-996aaf00-aaaa-11eb-877f-2433751c54e1.png" alt="image" style="zoom: 50%;" />

<br/>

### SQL로 인덱스 만들고 사용하기

#### CREATE INDEX

- ##### Clustered Index

  MySQL에서는 자동으로 각 테이블이 Primary Key에 대한 Clustered Index가 만들어진다.

  Primary Key로 설정된 Clustered Index를 바꾸는 경우는 많지 않다. 하지만, 만약 Primary Key가 아닌 다른 컬럼을 Clustered Index로 사용하고 싶을 때는 다음과 같이 설정한다.

  1. Clustered Index는 테이블당 하나씩 밖에 있을 수 없기 때문에, 먼저 기존의 인덱스를 삭제한다.

  2. 인덱스를 추가한다.

     ```mysql
     CREATE CLUSTERED INDEX {index_name} ON {table_name} (column_name);
     ```

- ##### Non-Clustered Index

  Non-Clustered Index는 개수 상관없이 여러 개 만들 수 있기 때문에 이미 있는 인덱스를 지울 필요가 없다.

  ```mysql
  CREATE INDEX {index_name} ON {table_name} (column_name);
  ```

- ##### Composite Index

  Clustered/Non-Clustered Index 모두, 하나의 컬럼이 아니라, 여러 개의 컬럼에 대해서 Composite Index를 만들 수 있다.

  ```mysql
  CREATE INDEX {index_name} ON {table_name} (column_name_1, column_name_2, ...);
  ```

#### Check Index

```mysql
SHOW INDEX FROM {table_name};
```

#### Delete Index

인덱스를 삭제하기 위해서는 항상 인덱스 이름을 알고 있어야한다. (Check Index)

```mysql
DROP INDEX {index_name} ON {table_name};
```

#### Use Index

조회할 때 인덱스를 사용하고 싶을 경우 인덱스가 있으나 없으나 똑같이 SELECT 문을 사용하여 조회하면 된다. DBMS가 알아서 인덱스를 사용할 수 있는 쿼리들에 대해서는 인덱스를 사용해주기 때문이다.